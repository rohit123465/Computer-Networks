#include "sniff.h"
#include "hashset.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <pcap.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include "dispatch.h"
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include "packetqueue.h"
#include <pthread.h>

dynamicArray sourceIPAddressSet;
int SYNCount;
int ARPCount;
int googleURLCount;
int bbcURLCount;
int totalURLCount;

  // Application main sniffing loop
void sniff(char *interface, int verbose) {
  
  char errbuf[PCAP_ERRBUF_SIZE]; //prints an error message buffer  
  pcap_t * pcap_handle = pcap_open_live(interface, 4096, 1, 1000, errbuf);//the pcap_open_live() functions initiates the packet capturing session at the specified interface
  if (pcap_handle == NULL) {
    fprintf(stderr, "Unable to open interface %s\n", errbuf);
    exit(EXIT_FAILURE);
  } else {
    printf("SUCCESS! Opened %s for capture\n", interface);
  }
    initializeArray(&sourceIPAddressSet);
    
    work_queue=create_queue();//the queue is initialized to insert incoming packets 
    threadTerminate=0;
    createWorkerThreads();//method is called from dispatch which dequeues the packets and sends them to analyse for malicious attacks
 
  void handleInterrupt(int signal){
    /*sprintf() method converts the integer to a string. In this case, the integer global counters 
      are converted to a string while displayed in the terminal*/
    char *heading="Intrusion Detection Report:\n";
    char SYNCNT[40];
    sprintf(SYNCNT,"%d",SYNCount);
    char *SYNHeader=" SYN packets detected from ";
    char IPCount[40];
    sprintf(IPCount,"%ld",getSize(&sourceIPAddressSet));
    char *IPs=" different IPs (syn attack)\n";
    char ARPCNT[40];
    sprintf(ARPCNT,"%d",ARPCount);
    char *ARPHeader=" ARP responses (cache poisoning)\n";
    totalURLCount=googleURLCount+bbcURLCount;
    char URLCNT[40];
    sprintf(URLCNT,"%d",totalURLCount);
    char *URLHeader=" URL Blacklist violations (";
    char googleCNT[40];
    sprintf(googleCNT,"%d",googleURLCount);
    char *URLHeader2=" google and ";
    char bbcCNT[40];
    sprintf(bbcCNT,"%d",bbcURLCount);
    char *URLHeader3=" bbc)\n";
    /*In the signal handler method, signal-safe functions such as write ()is used 
        to prevent memory leaks when running the code  with valgrind*/
    write(1,heading,strlen(heading));
    write(1,SYNCNT,strlen(SYNCNT));
    write(1,SYNHeader,strlen(SYNHeader));
    write(1,IPCount,strlen(IPCount));
    write(1,IPs,strlen(IPs));
    write(1,ARPCNT,strlen(ARPCNT));
    write(1,ARPHeader,strlen(ARPHeader));
    write(1,URLCNT,strlen(URLCNT));
    write(1,URLHeader,strlen(URLHeader));
    write(1,googleCNT,strlen(googleCNT));
    write(1,URLHeader2,strlen(URLHeader2));
    write(1,bbcCNT,strlen(bbcCNT));
    write(1,URLHeader3,strlen(URLHeader3));
    pcap_breakloop(pcap_handle);//forces the pcap_loop method to return the number of processed packets
  }

  signal(SIGINT, handleInterrupt);/*SIGINT is an attention signal generated by the user. The method calls 
    the signal handler method handleInterrupt which passes the signal as the parameter to print 
    the intrusion detection report after the user presses Control C*/
  
    
  void packet_handler(unsigned char*user, const struct pcap_pkthdr* pkthdr,const unsigned char*packet){
    dispatch(pkthdr, packet, verbose);
  }

    pcap_loop(pcap_handle,0,packet_handler,NULL);
    pcap_close(pcap_handle);
    threadTerminate=1;
    pthread_cond_broadcast(&queueCondition);//used to unblock all worker threads blocked in the condition variable (in this case queueCondition)
    joinThreads();
    destroy_queue(work_queue);
    freeDynamicArray(&sourceIPAddressSet);
    _exit(0);//terminates the calling process and the file descriptors in the processes are also closed
  }
  
  //The dump method is not used or called for analysing packets. It is mainly used for debugging purposes
 void dump(const unsigned char *data, int length) {
  unsigned int i;
  static unsigned long pcount=0;
  // Decode ethernet packet Header
  struct ether_header *eth_header = (struct ether_header *) data;
  printf("\n\n === PACKET %ld HEADER ===", pcount);
  printf("\nSource MAC: ");
  for (i = 0; i < 6; i++) {
    printf("%02x", eth_header->ether_shost[i]);
    if (i < 5) {
      printf(":");
    }
  }
  printf("\nDestination MAC: ");
  for (i = 0; i < 6; i++) {
    printf("%02x", eth_header->ether_dhost[i]);
    if (i < 5) {
      printf(":");
    }
  }
  
  printf("\nType: %hu\n", ntohs(eth_header->ether_type));   

  printf("\n\n === PACKET %ld DATA == \n", pcount);
  // Decode Packet Data (Skipping over the header)
  int data_bytes = length - ETH_HLEN;//data_bytes represents the actual data excluding headers
  const unsigned char *payload = data + ETH_HLEN;//sets the position of the pointer after the header
  const static int output_sz = 20; // Output this many bytes at a time
  while (data_bytes > 0) {
    int output_bytes = data_bytes < output_sz ? data_bytes : output_sz;
    // Print data in raw hexadecimal form
    for (i = 0; i < output_sz; i++) {
      if (i < output_bytes) {
        printf("%02x ", payload[i]);
      } else {
        printf ("   "); // Maintain padding for partial lines
      }
    }
    printf ("| ");
    // Print data in ascii form
    for (i = 0; i < output_bytes; i++) {
      char byte = payload[i];
      if (byte > 31 && byte < 127) {
        // Byte is in printable ascii range
        printf("%c", byte);
      } else {
        printf(".");
      }
    }
    printf("\n");
    payload += output_bytes;//the pointer points to the beginning of the next set of packets 
    data_bytes -= output_bytes;//to track remaining bytes in payload
  }
  pcount++;//increments the packet count
} 
 